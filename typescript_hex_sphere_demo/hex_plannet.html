<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Procedural Planet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }
    </style>
  </head>
  <body>
  
  <script type="importmap">
	{
	  "imports": {
		"three": "https://unpkg.com/three@0.160.0/build/three.module.js"
	  }
	}
	</script>
    <script type="module">
	import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
	import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

	//const script = document.createElement("script");
	//script.type = "module";
	//script.textContent = `import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js"; /* code */`;
	//document.body.appendChild(script);

    /*
  	class Noise {
  		static hash(x: number, y: number, z: number): number {
  			return Math.sin(x * 127.1 + y * 311.7 + z * 74.7) * 43758.5453 % 1;
  		}
  	}
  	class FBM {
  	  static sample(x: number, y: number, z: number, octaves = 5): number {
  		let value = 0;
  		let amplitude = 0.5;
  		let frequency = 1;
  
  		for (let i = 0; i < octaves; i++) {
  		  value += amplitude * Noise.hash(x * frequency, y * frequency, z * frequency);
  		  frequency *= 2;
  		  amplitude *= 0.5;
  		}
  
  		return value;
  	  }
  	}
  	class HeightGenerator {
  	  getHeight(normal: THREE.Vector3): number {
  		return FBM.sample(normal.x, normal.y, normal.z) * 0.2;
  	  }
  	}
  	class PlanetMesh {
  	  mesh: THREE.Mesh;
  
  	  constructor() {
  		const geometry = new THREE.IcosahedronGeometry(1, 6);
  		const generator = new HeightGenerator();
  
  		const position = geometry.attributes.position;
  		for (let i = 0; i < position.count; i++) {
  		  const v = new THREE.Vector3().fromBufferAttribute(position, i);
  		  const height = generator.getHeight(v.normalize());
  		  v.multiplyScalar(1 + height);
  		  position.setXYZ(i, v.x, v.y, v.z);
  		}
  
  		geometry.computeVertexNormals();
  
  		const material = new THREE.MeshStandardMaterial({
  		  color: 0x4caf50,
  		  flatShading: false
  		});
  
  		this.mesh = new THREE.Mesh(geometry, material);
  	  }
  	}
  	class Planet {
  	  object3D = new THREE.Object3D();
  	  mesh: PlanetMesh;
  
  	  constructor() {
  		this.mesh = new PlanetMesh();
  		this.object3D.add(this.mesh.mesh);
  	  }
  	}
  	function createLighting(scene: THREE.Scene) {
  	  // Soft global light (space ambient)
  	  const ambient = new THREE.AmbientLight(0xffffff, 0.3);
  	  scene.add(ambient);
  
  	  // Main sun light
  	  const directional = new THREE.DirectionalLight(0xffffff, 1.2);
  	  directional.position.set(5, 3, 5);
  	  directional.castShadow = true;
  
  	  directional.shadow.mapSize.width = 2048;
  	  directional.shadow.mapSize.height = 2048;
  
  	  scene.add(directional);
  	}
  	class CameraController {
  	  camera: THREE.PerspectiveCamera;
  
  	  private radius = 3;
  	  private theta = 0;
  	  private phi = Math.PI / 2;
  
  	  private isDragging = false;
  	  private lastX = 0;
  	  private lastY = 0;
  
  	  constructor(domElement: HTMLElement) {
  		this.camera = new THREE.PerspectiveCamera(
  		  60,
  		  window.innerWidth / window.innerHeight,
  		  0.01,
  		  1000
  		);
  
  		this.updateCamera();
  
  		domElement.addEventListener("mousedown", this.onMouseDown);
  		domElement.addEventListener("mousemove", this.onMouseMove);
  		domElement.addEventListener("mouseup", this.onMouseUp);
  		domElement.addEventListener("wheel", this.onWheel);
  	  }
  
  	  update() {
  		this.updateCamera();
  	  }
  
  	  resize() {
  		this.camera.aspect = window.innerWidth / window.innerHeight;
  		this.camera.updateProjectionMatrix();
  	  }
  
  	  private updateCamera() {
  		const x = this.radius * Math.sin(this.phi) * Math.cos(this.theta);
  		const y = this.radius * Math.cos(this.phi);
  		const z = this.radius * Math.sin(this.phi) * Math.sin(this.theta);
  
  		this.camera.position.set(x, y, z);
  		this.camera.lookAt(0, 0, 0);
  	  }
  
  	  private onMouseDown = (e: MouseEvent) => {
  		this.isDragging = true;
  		this.lastX = e.clientX;
  		this.lastY = e.clientY;
  	  };
  
  	  private onMouseMove = (e: MouseEvent) => {
  		if (!this.isDragging) return;
  
  		const dx = e.clientX - this.lastX;
  		const dy = e.clientY - this.lastY;
  
  		this.theta -= dx * 0.005;
  		this.phi -= dy * 0.005;
  		this.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.phi));
  
  		this.lastX = e.clientX;
  		this.lastY = e.clientY;
  	  };
  
  	  private onMouseUp = () => {
  		this.isDragging = false;
  	  };
  
  	  private onWheel = (e: WheelEvent) => {
  		this.radius += e.deltaY * 0.002;
  		this.radius = Math.max(1.5, Math.min(10, this.radius));
  	  };
  	} */
      
/* ---------- (JS VERSION) ---------- */
class Noise {
  static hash(x, y, z) {
    return (Math.sin(x * 127.1 + y * 311.7 + z * 74.7) * 43758.5453) % 1;
  }
}
class FBM {
  static sample(x, y, z, octaves = 5) {
    let value = 0;
    let amplitude = 0.5;
    let frequency = 1;
    for (let i = 0; i < octaves; i++) {
      value += amplitude * Noise.hash(x * frequency, y * frequency, z * frequency);
      frequency *= 2;
      amplitude *= 0.5;
    }
    return value;
  }
}
class HeightGenerator {
  getHeight(normal) {
    return FBM.sample(normal.x, normal.y, normal.z) * 0.2;
  }
}
class PlanetMesh {
  constructor() {
    const geometry = new THREE.IcosahedronGeometry(1, 6);
    const generator = new HeightGenerator();
    const position = geometry.attributes.position;
    for (let i = 0; i < position.count; i++) {
      const v = new THREE.Vector3().fromBufferAttribute(position, i);
      const height = generator.getHeight(v.clone().normalize());
      v.multiplyScalar(1 + height);
      position.setXYZ(i, v.x, v.y, v.z);
    }
    geometry.computeVertexNormals();
    const material = new THREE.MeshStandardMaterial({
      color: 0x4caf50
    });
    this.mesh = new THREE.Mesh(geometry, material);
  }
}

class HexSphere {
  static create(subdivisions, radius)/*: THREE.BufferGeometry */ {
    let vertices = HexSphere.icosahedronVertices();
    let indices = HexSphere.icosahedronIndices();

    for (let i = 0; i < subdivisions; i++) {
      ({ vertices, indices } = HexSphere.subdivide(vertices, indices));
    }

    // Project to sphere
    vertices = vertices.map(v => v.normalize().multiplyScalar(radius));

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(vertices.length * 3);

    vertices.forEach((v, i) => {
      positions[i * 3 + 0] = v.x;
      positions[i * 3 + 1] = v.y;
      positions[i * 3 + 2] = v.z;
    });

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geometry.setIndex(indices);
    geometry.computeVertexNormals();

    return geometry;
  }

  static icosahedronVertices()/*: THREE.Vector3[]*/ {
    const t = (1 + Math.sqrt(5)) / 2;
    return [
      new THREE.Vector3(-1,  t,  0),
      new THREE.Vector3( 1,  t,  0),
      new THREE.Vector3(-1, -t,  0),
      new THREE.Vector3( 1, -t,  0),
      new THREE.Vector3( 0, -1,  t),
      new THREE.Vector3( 0,  1,  t),
      new THREE.Vector3( 0, -1, -t),
      new THREE.Vector3( 0,  1, -t),
      new THREE.Vector3( t,  0, -1),
      new THREE.Vector3( t,  0,  1),
      new THREE.Vector3(-t,  0, -1),
      new THREE.Vector3(-t,  0,  1),
    ];
  }

  static icosahedronIndices()/*: number[]*/ {
    return [
      0,11,5, 0,5,1, 0,1,7, 0,7,10, 0,10,11,
      1,5,9, 5,11,4, 11,10,2, 10,7,6, 7,1,8,
      3,9,4, 3,4,2, 3,2,6, 3,6,8, 3,8,9,
      4,9,5, 2,4,11, 6,2,10, 8,6,7, 9,8,1,
    ];
  }

  static subdivide(
    vertices/*: THREE.Vector3[]*/,
    indices/*: number[]*/
  )/*: { vertices: THREE.Vector3[]; indices: number[] }*/ {

    const newVertices = [...vertices];
    const newIndices= [];
    const midpointCache = new Map();

    const midpoint = (a, b) => {
      const key = a < b ? `${a}_${b}` : `${b}_${a}`;
      if (midpointCache.has(key)) return midpointCache.get(key);

      const v = vertices[a].clone().add(vertices[b]).multiplyScalar(0.5);
      const index = newVertices.length;
      newVertices.push(v);
      midpointCache.set(key, index);
      return index;
    };

    for (let i = 0; i < indices.length; i += 3) {
      const a = indices[i];
      const b = indices[i + 1];
      const c = indices[i + 2];

      const ab = midpoint(a, b);
      const bc = midpoint(b, c);
      const ca = midpoint(c, a);

      newIndices.push(
        a, ab, ca,
        b, bc, ab,
        c, ca, bc,
        ab, bc, ca
      );
    }

    return { vertices: newVertices, indices: newIndices };
  }
}

class Planet {
  constructor() {
	////new THREE.Object3D();
    //this.hexSphere = new HexSphere;
    this.geometry = HexSphere.create(3, 1);
	this.surface = new THREE.Mesh(
	  geometry,
	  new THREE.MeshStandardMaterial({
		color: 0x4caf50,
		roughness: 0.8,
	  })
	);
	scene.add(surface);
//	this.mesh = new PlanetMesh();
//    this.object3D.add(this.mesh.mesh);
  }
}

function createLighting(scene) {
  scene.add(new THREE.AmbientLight(0xffffff, 0.3));

  const sun = new THREE.DirectionalLight(0xffffff, 1.2);
  sun.position.set(5, 3, 5);
  scene.add(sun);
}

/* ---------- BOOTSTRAP (REQUIRED) ---------- */
const scene = new THREE.Scene();
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.01,
  1000
);
camera.position.set(3, 2, 3);
camera.lookAt(0, 0, 0);

// Orbit controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

createLighting(scene);
const planet = new Planet();
scene.add(planet.object3D);
function animate() {
  requestAnimationFrame(animate);
  planet.object3D.rotation.y += 0.002;
  renderer.render(scene, camera);
}
animate();
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
   </script>
  </body>
</html>
