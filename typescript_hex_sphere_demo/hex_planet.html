<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Procedural Planet â€“ Hex Sphere</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
</style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';

/* ðŸ”· SHARED CORNER CACHE */
const sharedCornerCache = new Map();
function getSharedCorner(v) {
  const key =
    v.x.toFixed(6) + "_" +
    v.y.toFixed(6) + "_" +
    v.z.toFixed(6);
  if (!sharedCornerCache.has(key)) sharedCornerCache.set(key, v);
  return sharedCornerCache.get(key);
}

/* ðŸ”· GOLDBERG SPHERE */
class GoldbergSphere {
  static create(subdivisions, radius) {
    let vertices = this.icosahedronVertices();
    let indices = this.icosahedronIndices();
    for (let i = 0; i < subdivisions; i++) {
      ({ vertices, indices } = this.subdivide(vertices, indices));
    }
    vertices = vertices.map(v => v.normalize().multiplyScalar(radius));
    const faceCenters = this.computeFaceCenters(vertices, indices);
    const vertexFaces = this.buildAdjacency(indices, vertices.length);
    return { cells: this.buildCells(vertices, indices, faceCenters, vertexFaces, radius) };
  }

  static buildCells(vertices, indices, faceCenters, vertexFaces, radius) {
    const cells = [];
    for (let vi = 0; vi < vertexFaces.length; vi++) {
      const faces = vertexFaces[vi];
      if (faces.length < 5) continue;
      const center = vertices[vi].clone().normalize().multiplyScalar(radius);
      const normal = center.clone().normalize();
      const corners = faces.map(fi => faceCenters[fi].clone().multiplyScalar(radius));
      const tangent = new THREE.Vector3().crossVectors(normal, Math.abs(normal.y)<0.9?new THREE.Vector3(0,1,0):new THREE.Vector3(1,0,0)).normalize();
      const bitangent = new THREE.Vector3().crossVectors(normal, tangent);
      corners.sort((a,b)=>{
        const da=a.clone().sub(center), db=b.clone().sub(center);
        return Math.atan2(da.dot(bitangent),da.dot(tangent)) - Math.atan2(db.dot(bitangent),db.dot(tangent));
      });
      cells.push({ center, corners, isPentagon: corners.length===5 });
    }
    return cells;
  }

  static computeFaceCenters(vertices, indices) {
    const centers = [];
    for (let i = 0; i < indices.length; i += 3) {
      const a = vertices[indices[i]], b = vertices[indices[i+1]], c = vertices[indices[i+2]];
      centers.push(new THREE.Vector3().add(a).add(b).add(c).divideScalar(3).normalize());
    }
    return centers;
  }

  static buildAdjacency(indices, count) {
    const vf = Array(count).fill(0).map(() => []);
    for (let i = 0; i < indices.length; i += 3) {
      const f = i/3;
      vf[indices[i]].push(f);
      vf[indices[i+1]].push(f);
      vf[indices[i+2]].push(f);
    }
    return vf;
  }

  static subdivide(vertices, indices) {
    const newVerts = [...vertices], newIdx = [], cache = new Map();
    const mid = (a,b) => {
      const k = a<b?`${a}_${b}`:`${b}_${a}`;
      if (cache.has(k)) return cache.get(k);
      const v = vertices[a].clone().add(vertices[b]).multiplyScalar(0.5);
      const i = newVerts.length; newVerts.push(v); cache.set(k,i); return i;
    };
    for (let i=0;i<indices.length;i+=3){
      const a=indices[i],b=indices[i+1],c=indices[i+2];
      const ab=mid(a,b), bc=mid(b,c), ca=mid(c,a);
      newIdx.push(a,ab,ca, b,bc,ab, c,ca,bc, ab,bc,ca);
    }
    return { vertices:newVerts, indices:newIdx };
  }

  static icosahedronVertices() {
    const t=(1+Math.sqrt(5))/2;
    return [
      new THREE.Vector3(-1,t,0), new THREE.Vector3(1,t,0),
      new THREE.Vector3(-1,-t,0), new THREE.Vector3(1,-t,0),
      new THREE.Vector3(0,-1,t), new THREE.Vector3(0,1,t),
      new THREE.Vector3(0,-1,-t), new THREE.Vector3(0,1,-t),
      new THREE.Vector3(t,0,-1), new THREE.Vector3(t,0,1),
      new THREE.Vector3(-t,0,-1), new THREE.Vector3(-t,0,1)
    ];
  }

  static icosahedronIndices() {
    return [
      0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,
      1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,
      3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,
      4,9,5,2,4,11,6,2,10,8,6,7,9,8,1
    ];
  }
}

/* ðŸ”· TRIANGULATE POLYGON */
function triangulatePolygon3D(corners, normal) {
  const tangent = new THREE.Vector3().crossVectors(normal, Math.abs(normal.y)<0.9?new THREE.Vector3(0,1,0):new THREE.Vector3(1,0,0)).normalize();
  const bitangent = new THREE.Vector3().crossVectors(normal, tangent);
  const pts2D = corners.map(p=>new THREE.Vector2(p.dot(tangent),p.dot(bitangent)));
  const tris = THREE.ShapeUtils.triangulateShape(pts2D, []);
  const out=[];
  for(const t of tris) for(const i of t) out.push(corners[i]);
  return out;
}

/* ðŸ”· PLANET WITH CENTER SPHERES */
class Planet {
  constructor(scene){
    this.object3D = new THREE.Object3D();
    this.goldberg = GoldbergSphere.create(3,1);
    this.centerSpheres = []; // collect spheres for GUI toggle

    this.goldberg.cells.forEach(cell=>{
      const geom = new THREE.BufferGeometry();
      const verts = [];
      const normal = cell.center.clone().normalize();

      const projectedCorners = cell.corners.map(corner=>{
        const toCorner = corner.clone().sub(cell.center);
        const dist = toCorner.dot(normal);
        return corner.clone().sub(normal.clone().multiplyScalar(dist));
      });

      const triangles = triangulatePolygon3D(projectedCorners, normal);
      triangles.forEach(v=>verts.push(v.x,v.y,v.z));
      geom.setAttribute("position",new THREE.Float32BufferAttribute(verts,3));
      geom.computeVertexNormals();

      const tileMesh = new THREE.Mesh(
        geom,
        new THREE.MeshStandardMaterial({
          color: cell.isPentagon?0xff7043:0x4caf50,
          flatShading:false,
          roughness:0.8,
          metalness:0.0
        })
      );

      // ðŸ”µ TILE CENTER SPHERE
      const centerSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.015,12,12),
        new THREE.MeshStandardMaterial({
          color:0x66ccff,
          emissive:0x226688,
          emissiveIntensity:0.4,
          roughness:0.4
        })
      );

      // convert to local tileMesh space and offset outward
      const localCenter = cell.center.clone();
      tileMesh.worldToLocal(localCenter);
      localCenter.add(normal.clone().multiplyScalar(0.04));
      centerSphere.position.copy(localCenter);

      tileMesh.add(centerSphere);
      tileMesh.userData = { cell, normal: normal.clone(), phase: Math.random()*Math.PI*2, centerSphere };
      this.centerSpheres.push(centerSphere);

      this.object3D.add(tileMesh);
    });

    //this.buildGraph();
    //Expected:
    //{ 5: 12, 6: 240 }
    //this.enforceSixNeighbors();
    //Expected:
    //{ 6: 252 }
    
    scene.add(this.object3D);
  }//end constructor
  buildGraph() {
    // Map center position â†’ cell index
    const centerMap = new Map();
    this.goldberg.cells.forEach((cell, i) => {
      const key = cell.center.toArray().map(v => v.toFixed(6)).join("_");
      centerMap.set(key, i);
    });
    // Initialize neighbor list
    this.graph = this.goldberg.cells.map(() => []);
    // Two cells are neighbors if they share 2 corners
    for (let i = 0; i < this.goldberg.cells.length; i++) {
      for (let j = i + 1; j < this.goldberg.cells.length; j++) {
        const a = this.goldberg.cells[i];
        const b = this.goldberg.cells[j];
        let shared = 0;
        for (let ca of a.corners) {
          for (let cb of b.corners) {
            if (ca.distanceTo(cb) < 1e-5) shared++;
          }
        }
        if (shared >= 2) {
          this.graph[i].push(j);
          this.graph[j].push(i);
        }
      }
    }
    console.log("Initial Valence Histogram:");
    this.printValenceHistogram();
  }//end buildgraph
  printValenceHistogram() {
    const hist = {};
    this.graph.forEach(n => {
      hist[n.length] = (hist[n.length] || 0) + 1;
    });
    console.log(hist);
  }//end printValenceHistogram
  //expected
  //{ 5: 12, 6: 240 }
  enforceSixNeighbors() {
    for (let i = 0; i < this.graph.length; i++) {
      while (this.graph[i].length < 6) {
        const secondRing = new Set();
        // gather neighbors of neighbors
        this.graph[i].forEach(n => {
          this.graph[n].forEach(nn => {
            if (nn !== i && !this.graph[i].includes(nn)) {
              secondRing.add(nn);
            }
          });
        });
        if (secondRing.size === 0) break;
        // choose best candidate by minimal angular deviation
        let best = null;
        let bestAngle = Infinity;
        const center = this.goldberg.cells[i].center.clone().normalize();
        secondRing.forEach(candidate => {
          const dir = this.goldberg.cells[candidate].center.clone().normalize();
          const angle = center.angleTo(dir);
          if (angle < bestAngle) {
            bestAngle = angle;
            best = candidate;
          }
        });
        if (best === null) break;
        this.graph[i].push(best);
        this.graph[best].push(i);
      }
    }
    console.log("After Enforcement:");
    this.printValenceHistogram();
  }
}

/* ðŸ”· BOOTSTRAP */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
camera.position.set(3,2,3);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.4));
const sun = new THREE.DirectionalLight(0xffffff,1.2);
sun.position.set(5,3,5);
scene.add(sun);

const controls = new OrbitControls(camera, renderer.domElement);
const planet = new Planet(scene);

/* ðŸ”· GUI TOGGLE FOR CENTER SPHERES */
const gui = new GUI({ title:'Tiles', width:220 });
gui.domElement.style.backgroundColor = '#1e1e1e';
gui.domElement.style.color = '#eee';

const settings = { showSpheres:true };
gui.add(settings,'showSpheres').name('Show Centers').onChange(value=>{
  planet.centerSpheres.forEach(s => s.visible = value);
});

/* ðŸ”· VORONOI SEED SYSTEM */
const voronoiSettings = {
  seedIndices: [],   // stores the 3 chosen indices
  activeSeed: "None",
  generateSeeds: () => generateRandomSeeds()
};

const seedFolder = gui.addFolder("Voronoi Seeds");
seedFolder.add(voronoiSettings, "generateSeeds").name("Generate Random Seeds");

seedFolder.add(voronoiSettings, "activeSeed", ["None", "Seed 0", "Seed 1", "Seed 2"])
  .name("View Seed")
  .onChange(updateSeedVisibility);

seedFolder.add(voronoiSettings, "showVoronoiSeedSpheres")
  .name('Show Voronoi Seed Spheres')
  .onChange(value=>{
    voronoiSettings.seedIndices[activeSeed].forEach(s => s.visible = value);
  });

function generateRandomSeeds() {
  // reset previous highlights
  planet.centerSpheres.forEach(s => {
    s.material.emissive.setHex(0x226688);
  });
  const total = planet.centerSpheres.length;
  const selected = new Set();
  while (selected.size < 3) {
    selected.add(Math.floor(Math.random() * total));
  }
  voronoiSettings.seedIndices = Array.from(selected);
  console.log("New Voronoi Seeds:", voronoiSettings.seedIndices);
  // highlight all 3 in red initially
  voronoiSettings.seedIndices.forEach(i => {
    planet.centerSpheres[i].material.emissive.setHex(0xff0000);
  });
  voronoiSettings.activeSeed = "None";
}

function updateSeedVisibility(value) {
  // reset all spheres
  planet.centerSpheres.forEach(s => {
    s.material.emissive.setHex(0x226688);
  });
  if (value === "None") {
    return;
  }
  const index = parseInt(value.split(" ")[1]);
  if (
    voronoiSettings.seedIndices.length === 3 &&
    voronoiSettings.seedIndices[index] !== undefined
  ) {
    const sphereIndex = voronoiSettings.seedIndices[index];
    planet.centerSpheres[sphereIndex].material.emissive.setHex(0x00ff00);
  }
}

/* =========================================================
   ðŸ”· ANIMATION LOOP
========================================================= */
function animate(){
  requestAnimationFrame(animate);
  planet.object3D.rotation.y += 0.002;
  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>
