<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Procedural Planet â€“ Hex Sphere</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
</style>
</head>
<body>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';

/* =========================================================
   ðŸ”· SHARED CORNER CACHE
========================================================= */
const sharedCornerCache = new Map();
function getSharedCorner(v) {
  const key =
    v.x.toFixed(6) + "_" +
    v.y.toFixed(6) + "_" +
    v.z.toFixed(6);
  if (!sharedCornerCache.has(key)) sharedCornerCache.set(key, v);
  return sharedCornerCache.get(key);
}

/* =========================================================
   ðŸ”· GOLDBERG SPHERE
========================================================= */
class GoldbergSphere {
  static create(subdivisions, radius) {
    let vertices = this.icosahedronVertices();
    let indices = this.icosahedronIndices();
    for (let i = 0; i < subdivisions; i++) {
      ({ vertices, indices } = this.subdivide(vertices, indices));
    }
    vertices = vertices.map(v => v.normalize().multiplyScalar(radius));
    const faceCenters = this.computeFaceCenters(vertices, indices);
    const vertexFaces = this.buildAdjacency(indices, vertices.length);
    return { cells: this.buildCells(vertices, indices, faceCenters, vertexFaces, radius) };
  }

  static buildCells(vertices, indices, faceCenters, vertexFaces, radius) {
    const cells = [];
    for (let vi = 0; vi < vertexFaces.length; vi++) {
      const faces = vertexFaces[vi];
      if (faces.length < 5) continue;
      const center = vertices[vi].clone().normalize().multiplyScalar(radius);
      const normal = center.clone().normalize();
      const corners = faces.map(fi => faceCenters[fi].clone().multiplyScalar(radius));
      const tangent = new THREE.Vector3().crossVectors(normal, Math.abs(normal.y)<0.9?new THREE.Vector3(0,1,0):new THREE.Vector3(1,0,0)).normalize();
      const bitangent = new THREE.Vector3().crossVectors(normal, tangent);
      corners.sort((a,b)=>{
        const da=a.clone().sub(center), db=b.clone().sub(center);
        return Math.atan2(da.dot(bitangent),da.dot(tangent)) - Math.atan2(db.dot(bitangent),db.dot(tangent));
      });
      cells.push({ center, corners, isPentagon: corners.length===5 });
    }
    return cells;
  }

  static computeFaceCenters(vertices, indices) {
    const centers = [];
    for (let i = 0; i < indices.length; i += 3) {
      const a = vertices[indices[i]], b = vertices[indices[i+1]], c = vertices[indices[i+2]];
      centers.push(new THREE.Vector3().add(a).add(b).add(c).divideScalar(3).normalize());
    }
    return centers;
  }

  static buildAdjacency(indices, count) {
    const vf = Array(count).fill(0).map(() => []);
    for (let i = 0; i < indices.length; i += 3) {
      const f = i/3;
      vf[indices[i]].push(f);
      vf[indices[i+1]].push(f);
      vf[indices[i+2]].push(f);
    }
    return vf;
  }

  static subdivide(vertices, indices) {
    const newVerts = [...vertices], newIdx = [], cache = new Map();
    const mid = (a,b) => {
      const k = a<b?`${a}_${b}`:`${b}_${a}`;
      if (cache.has(k)) return cache.get(k);
      const v = vertices[a].clone().add(vertices[b]).multiplyScalar(0.5);
      const i = newVerts.length; newVerts.push(v); cache.set(k,i); return i;
    };
    for (let i=0;i<indices.length;i+=3){
      const a=indices[i],b=indices[i+1],c=indices[i+2];
      const ab=mid(a,b), bc=mid(b,c), ca=mid(c,a);
      newIdx.push(a,ab,ca, b,bc,ab, c,ca,bc, ab,bc,ca);
    }
    return { vertices:newVerts, indices:newIdx };
  }

  static icosahedronVertices() {
    const t=(1+Math.sqrt(5))/2;
    return [
      new THREE.Vector3(-1,t,0), new THREE.Vector3(1,t,0),
      new THREE.Vector3(-1,-t,0), new THREE.Vector3(1,-t,0),
      new THREE.Vector3(0,-1,t), new THREE.Vector3(0,1,t),
      new THREE.Vector3(0,-1,-t), new THREE.Vector3(0,1,-t),
      new THREE.Vector3(t,0,-1), new THREE.Vector3(t,0,1),
      new THREE.Vector3(-t,0,-1), new THREE.Vector3(-t,0,1)
    ];
  }

  static icosahedronIndices() {
    return [
      0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,
      1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,
      3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,
      4,9,5,2,4,11,6,2,10,8,6,7,9,8,1
    ];
  }
}

/* =========================================================
   ðŸ”· TRIANGULATE POLYGON
========================================================= */
function triangulatePolygon3D(corners, normal) {
  const tangent = new THREE.Vector3().crossVectors(normal, Math.abs(normal.y)<0.9?new THREE.Vector3(0,1,0):new THREE.Vector3(1,0,0)).normalize();
  const bitangent = new THREE.Vector3().crossVectors(normal, tangent);
  const pts2D = corners.map(p=>new THREE.Vector2(p.dot(tangent),p.dot(bitangent)));
  const tris = THREE.ShapeUtils.triangulateShape(pts2D, []);
  const out=[];
  for(const t of tris) for(const i of t) out.push(corners[i]);
  return out;
}

/* =========================================================
   ðŸ”· PLANET WITH CENTER SPHERES
========================================================= */
class Planet {
  constructor(scene){
    this.object3D = new THREE.Object3D();
    this.goldberg = GoldbergSphere.create(3,1);
    this.centerSpheres = []; // collect spheres for GUI toggle

    this.goldberg.cells.forEach(cell=>{
      const geom = new THREE.BufferGeometry();
      const verts = [];
      const normal = cell.center.clone().normalize();

      const projectedCorners = cell.corners.map(corner=>{
        const toCorner = corner.clone().sub(cell.center);
        const dist = toCorner.dot(normal);
        return corner.clone().sub(normal.clone().multiplyScalar(dist));
      });

      const triangles = triangulatePolygon3D(projectedCorners, normal);
      triangles.forEach(v=>verts.push(v.x,v.y,v.z));
      geom.setAttribute("position",new THREE.Float32BufferAttribute(verts,3));
      geom.computeVertexNormals();

      const tileMesh = new THREE.Mesh(
        geom,
        new THREE.MeshStandardMaterial({
          color: cell.isPentagon?0xff7043:0x4caf50,
          flatShading:false,
          roughness:0.8,
          metalness:0.0
        })
      );

      // ðŸ”µ TILE CENTER SPHERE
      const centerSphere = new THREE.Mesh(
        new THREE.SphereGeometry(0.015,12,12),
        new THREE.MeshStandardMaterial({
          color:0x66ccff,
          emissive:0x226688,
          emissiveIntensity:0.4,
          roughness:0.4
        })
      );

      // convert to local tileMesh space and offset outward
      const localCenter = cell.center.clone();
      tileMesh.worldToLocal(localCenter);
      localCenter.add(normal.clone().multiplyScalar(0.04));
      centerSphere.position.copy(localCenter);

      tileMesh.add(centerSphere);
      tileMesh.userData = { cell, normal: normal.clone(), phase: Math.random()*Math.PI*2, centerSphere };
      this.centerSpheres.push(centerSphere);

      this.object3D.add(tileMesh);
    });

    scene.add(this.object3D);
  }
}

/* =========================================================
   ðŸ”· BOOTSTRAP
========================================================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 100);
camera.position.set(3,2,3);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.4));
const sun = new THREE.DirectionalLight(0xffffff,1.2);
sun.position.set(5,3,5);
scene.add(sun);

const controls = new OrbitControls(camera, renderer.domElement);
const planet = new Planet(scene);

/* =========================================================
   ðŸ”· GUI TOGGLE FOR CENTER SPHERES
========================================================= */
const gui = new GUI({ title:'Tiles', width:220 });
gui.domElement.style.backgroundColor = '#1e1e1e';
gui.domElement.style.color = '#eee';

const settings = { showSpheres:true };
gui.add(settings,'showSpheres').name('Show Centers').onChange(value=>{
  planet.centerSpheres.forEach(s => s.visible = value);
});

/* =========================================================
   ðŸ”· ANIMATION LOOP
========================================================= */
function animate(){
  requestAnimationFrame(animate);
  planet.object3D.rotation.y += 0.002;
  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>
